#include "battle_city.h"
#include "map.h"
#include "xparameters.h"
#include "xil_io.h"
#include "xio.h"
#include <math.h>
#include "obstacle_detect.h"

#include <stdbool.h>

//////////////////////////////////////////////////////////////////////////////
// Tweaking paramerters.

#define MAX_JUMP	                    70
#define STEP	                        16

//////////////////////////////////////////////////////////////////////////////

/*
 * GENERATED BY BC_MEM_PACKER
 * DATE: Wed Jul 08 21:00:48 2015
 */

// ***** 16x16 IMAGES *****
#define IMG_16x16_0			0x00FF
#define IMG_16x16_1			0x013F
#define IMG_16x16_2			0x017F
#define IMG_16x16_3			0x01BF
#define IMG_16x16_4			0x01FF
#define IMG_16x16_5			0x023F
#define IMG_16x16_6			0x027F
#define IMG_16x16_7			0x02BF
#define IMG_16x16_8			0x02FF
#define IMG_16x16_9			0x033F
#define IMG_16x16_A			0x037F
#define IMG_16x16_Black			0x03BF
#define IMG_16x16_cigle			0x03FF
#define IMG_16x16_coin			0x043F
#define IMG_16x16_crno			0x047F
#define IMG_16x16_D			0x04BF
#define IMG_16x16_E			0x04FF
#define IMG_16x16_enemi1			0x053F
#define IMG_16x16_I			0x057F
#define IMG_16x16_L			0x05BF
#define IMG_16x16_M			0x05FF
#define IMG_16x16_mario			0x063F
#define IMG_16x16_mario_left			0x067F
#define IMG_16x16_O			0x06BF
#define IMG_16x16_plavacigla			0x06FF
#define IMG_16x16_R			0x073F
#define IMG_16x16_W			0x077F
#define IMG_16x16_walken			0x07BF
#define IMG_16x16_walken_back			0x07FF
#define IMG_16x16_White			0x083F


//TODO: Ubijanje protivnika, score kad ubijes protivnika
//za nas: score da ispise, namestanje nogica

// ***** MAP *****

#define MAP_BASE_ADDRESS			2175 // MAP_OFFSET in battle_city.vhd
#define MAP_X							0
#define MAP_X2							640
#define MAP_Y							4
#define MAP_W							64
#define MAP_H							56

#define REGS_BASE_ADDRESS               ( MAP_BASE_ADDRESS + MAP_WIDTH * MAP_HEIGHT )
//#define REGS_BASE_ADDRESS               (5439)

#define BTN_DOWN( b )                   ( !( b & 0x01 ) )
#define BTN_UP( b )                     ( !( b & 0x10 ) )
#define BTN_LEFT( b )                   ( !( b & 0x02 ) )
#define BTN_RIGHT( b )                  ( !( b & 0x08 ) )
#define BTN_SHOOT( b )                  ( !( b & 0x04 ) )

#define TANK1_REG_L                     8
#define TANK1_REG_H                     9
#define TANK_AI_REG_L                   4
#define TANK_AI_REG_H                   5
#define TANK_AI_REG_L2                  6
#define TANK_AI_REG_H2                  7
#define TANK_AI_REG_L3                  2
#define TANK_AI_REG_H3                  3
#define TANK_AI_REG_L4                  10
#define TANK_AI_REG_H4                  11
#define TANK_AI_REG_L5                  12
#define TANK_AI_REG_H5                  13
#define TANK_AI_REG_L6                  14
#define TANK_AI_REG_H6                  15
#define TANK_AI_REG_L7                  16
#define TANK_AI_REG_H7                  17
#define BASE_REG_L						0
#define BASE_REG_H	                    1


int lives = 3;
int score = 0;
int mapPart = 1;
int udario_glavom_skok = 0;
int map_move = 0;
int coins = 0;
int udario_u_blok = 0;
int nivo = 0;
int start_fall = 0;
int jump_cnt = 0;
int char_move_cnt = 0;
int e_dir = 0;

typedef enum {
	b_false, b_true
} bool_t;

typedef enum {
	DIR_STILL, DIR_LEFT, DIR_RIGHT, DIR_UP, DIR_DOWN, DIR_UR, DIR_UL, DIR_DR, DIR_DL
} direction_t;

typedef enum {P_L, P_R, P_U, P_D, P_UR, P_UL, P_DR, P_DL} pos_t;
typedef enum {J_IDLE, J_GOING_UP, J_WAIT_UP_RELESE} jump_fsm_t;

typedef struct {
	unsigned int x;
	unsigned int y;
	direction_t dir;
	unsigned int type;

	bool_t destroyed;

	unsigned int reg_l;
	unsigned int reg_h;
} characters;

characters mario = {
		40,	                        	// x
		369,		                    // y
		DIR_RIGHT,              		// dir
		IMG_16x16_mario,  				// type

		b_false,                		// destroyed

		TANK1_REG_L,            		// reg_l
		TANK1_REG_H             		// reg_h
		};

characters enemie1 = {
		330,						// x
		431,                        // y

		DIR_LEFT,              			// dir
		IMG_16x16_enemi1,  				// type

		b_false,                		// destroyed

		TANK_AI_REG_L,            		// reg_l
		TANK_AI_REG_H             		// reg_h
		};

characters enemie2 = {
		450,							// x
		432,							// y
		DIR_RIGHT,              			// dir
		IMG_16x16_enemi1,  				// type

		b_false,                		// destroyed

		TANK_AI_REG_L2,            		// reg_l
		TANK_AI_REG_H2             		// reg_h
		};

characters enemie3 = {
		330,							// x
		272,							// y
		DIR_LEFT,              			// dir
		IMG_16x16_enemi1,  				// type

		b_false,                		// destroyed

		TANK_AI_REG_L3,            		// reg_l
		TANK_AI_REG_H3             		// reg_h
		};

characters enemie4 = {
		635,							// x
		431,							// y
		DIR_LEFT,              			// dir
		IMG_16x16_enemi1,  				// type

		b_false,                		// destroyed

		TANK_AI_REG_L4,            		// reg_l
		TANK_AI_REG_H4             		// reg_h
		};

unsigned int rand_lfsr113(void) {
	static unsigned int z1 = 12345, z2 = 12345;
	unsigned int b;

	b = ((z1 << 6) ^ z1) >> 13;
	z1 = ((z1 & 4294967294U) << 18) ^ b;
	b = ((z2 << 2) ^ z2) >> 27;
	z2 = ((z2 & 4294967288U) << 2) ^ b;

	return (z1 ^ z2);
}

static void chhar_spawn(characters * chhar) {
	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + chhar->reg_l ),
			(unsigned int )0x8F000000 | (unsigned int )chhar->type);
	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + chhar->reg_h ),
			(chhar->y << 16) | chhar->x);
}



void hard_reset(characters *ch){
	mapPart = 1;
	map_move = 0;
	coins = 0;
	nivo = 0;
	start_fall = 0;
	jump_cnt = 0;
	ch->x = 20;



	/*for(int i = 0; i < 30; i++){ vratiti pocetnu mapu na hard reset
		for(int j = 0; j <= 40; j++){
			map[i][j] = map_static[i][j];
		}
	}*/
}
static void map_update(characters * mario) {
	int x, y;
	long int addr;
	int i,j;


	if(lives == 0){
			for(i = 0; i < 30; i++){
				for(j = 0; j <= 40; j++){
					map[i][j] = lose_screen[i][j];
									}
			}
		}

	if(nivo == 0){
		map_move = 0;
		nivo = 1;
		for(i = 0; i <= 30; i++){
			for(j = 0; j <= 40; j++){
				map[i][j] = map1[i][j];
			}
		}
	}






	if(mario -> x <= 0 && nivo == 1){
		nivo = 0;
		map_move = 0;
		mario->x = 1;
		for(i = 0; i < 30; i++){
			for(j = 0; j <= 40; j++){
				map[i][j] = map1[i][j+map_move];
			}
		}
	}


	if(mario->x >= 620 && nivo == 1){
		nivo = 2;
		map_move += 40;
		mario->x = 41;
		for(i = 0; i < 30; i++){
			for(j = 0; j <= 40; j++){
				map[i][j] = map1[i][j+map_move];
			}
		}
	}


	if(mario -> x <= 0 && nivo == 2){
		nivo = 0;
		map_move = 0;
		mario->x = 620;
		for(i = 0; i < 30; i++){
			for(j = 0; j <= 40; j++){
				map[i][j] = map1[i][j+map_move];
			}
		}
	}
	if (mario-> x >= 620 && nivo == 2){
		nivo = 3;
		map_move = 0;
		map_move += 80;
		mario -> x = 10;
		for(i = 0; i < 30; i++){
			for(j = 0; j <= 40; j++){
				map[i][j] = map1[i][j+map_move];
			}
		}
	}
	if (mario-> x <= 0 && nivo == 3){
			nivo = 2;
			map_move = 0;
			map_move += 40;
			mario -> x = 620;
			for(i = 0; i < 30; i++){
				for(j = 0; j <= 40; j++){
					map[i][j] = map1[i][j+map_move];
				}
			}
		}
	if (mario-> x >= 620 && nivo == 3){
			nivo = 4;
			map_move = 0;
			map_move += 120;
			mario -> x = 10;
			for(i = 0; i < 30; i++){
				for(j = 0; j <= 40; j++){
					map[i][j] = map1[i][j+map_move];
				}
			}
		}
	if (mario-> x <= 0 && nivo == 4){
		nivo = 3;
		map_move = 0;
		map_move += 80;
		mario -> x = 620;
		for(i = 0; i < 30; i++){
			for(j = 0; j <= 40; j++){
				map[i][j] = map1[i][j+map_move];
				}
			}
		}
	if (mario-> x >= 620 && nivo == 4){
				nivo = 5;
				mario -> x = 10;
				lives = 3;
				for(i = 0; i < 30; i++){
					for(j = 0; j <= 40; j++){
						map[i][j] = map_win[i][j];
					}
				}
			}


	for (y = 0; y < MAP_HEIGHT; y++) {
		for (x = 0; x < MAP_WIDTH; x++) {
			addr = XPAR_BATTLE_CITY_PERIPH_0_BASEADDR
					+ 4 * (MAP_BASE_ADDRESS + y * MAP_WIDTH + x);
			switch (map[y][x]) {
			case 0:
				Xil_Out32(addr, IMG_16x16_crno);
				break;
			case 1:
				Xil_Out32(addr, IMG_16x16_mario);
				break;
			case 2:
				Xil_Out32(addr, IMG_16x16_cigle);
				break;
			case 3:
				Xil_Out32(addr, IMG_16x16_plavacigla);
				break;
			case 4:
				Xil_Out32(addr, IMG_16x16_enemi1);
				break;
			case 5:
				Xil_Out32(addr, IMG_16x16_coin);
				break;
			case 'm':
				Xil_Out32(addr, IMG_16x16_M);
				break;
			case 'a':
				Xil_Out32(addr, IMG_16x16_A);
				break;
			case 'r':
				Xil_Out32(addr, IMG_16x16_R);
				break;
			case 'i':
				Xil_Out32(addr, IMG_16x16_I);
				break;
			case 'o':
				Xil_Out32(addr, IMG_16x16_O);
				break;

			case 'g' :
				Xil_Out32(addr, IMG_16x16_1); // broj 1
				break;

			case 'j':
				if(coins == 0){
					Xil_Out32(addr, IMG_16x16_0);
				}
				else if(coins == 1){
					Xil_Out32(addr, IMG_16x16_1);
				}
				else if(coins == 2){
					Xil_Out32(addr, IMG_16x16_2);
				}
				else if(coins == 3){
					Xil_Out32(addr, IMG_16x16_3);
				}
				else if(coins == 4){
					Xil_Out32(addr, IMG_16x16_4);
				}
				else if(coins == 5){
					Xil_Out32(addr, IMG_16x16_5);
				}
				else if(coins == 6){
					Xil_Out32(addr, IMG_16x16_6);
				}
				else if(coins == 7){
					Xil_Out32(addr, IMG_16x16_7);
				}
				else if(coins == 8){
					Xil_Out32(addr, IMG_16x16_8);
				}
				else if(coins == 9){
					Xil_Out32(addr, IMG_16x16_9);
				}
				else{
					Xil_Out32(addr, IMG_16x16_0);
				}
				break;


			case 'v':							//nivo
				if(nivo == 1){
					Xil_Out32(addr, IMG_16x16_1);
				}
				else if(nivo == 2){
					Xil_Out32(addr, IMG_16x16_2);
				}
				else if(nivo == 3){
					Xil_Out32(addr, IMG_16x16_3);
				}
				else if(nivo == 4){
					Xil_Out32(addr, IMG_16x16_4);
				}
				break;

			case 'l':
				if(lives == 0){
					Xil_Out32(addr, IMG_16x16_0);
				}
				else if(lives == 1){
					Xil_Out32(addr, IMG_16x16_1);
				}
				else if(lives == 2){
					Xil_Out32(addr, IMG_16x16_2);
				}
				else if(lives == 3){
					Xil_Out32(addr, IMG_16x16_3);
				}
				else if(lives == 4){
					Xil_Out32(addr, IMG_16x16_4);
				}
				else if(lives == 5){
					Xil_Out32(addr, IMG_16x16_5);
				}
				else if(lives == 6){
					Xil_Out32(addr, IMG_16x16_6);
				}
				else if(lives == 7){
					Xil_Out32(addr, IMG_16x16_7);
				}
				else if(lives == 8){
					Xil_Out32(addr, IMG_16x16_8);
				}
				else if(lives == 9){
					Xil_Out32(addr, IMG_16x16_9);
				}
				else{
					Xil_Out32(addr, IMG_16x16_0);
				}
				break;
			case 'd':
				if(coins < 10){
					Xil_Out32(addr, IMG_16x16_0);
				}
				else{
					Xil_Out32(addr, IMG_16x16_1);
					coins = 0;
				}
				break;
			case 'b':
				Xil_Out32(addr, IMG_16x16_Black);
				break;

			case 'w':
				Xil_Out32(addr, IMG_16x16_White);
				break;
			default:
				Xil_Out32(addr, IMG_16x16_crno);
				break;
			}
		}
	}
}

static void map_reset(unsigned char * map) {

	unsigned int i;

	for (i = 0; i <= 20; i += 2) {
		Xil_Out32(
				XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + i ),
				(unsigned int )0x0F000000);
	}

}



void enemy_detection(characters* ch){
	u8 roundX = ch->x >> 4;
	u8 roundY = ch->y >> 4;

	/*if (map[roundY+1][roundX] == 4 || map[roundY+1][roundX+1] == 4 || map[roundY+1][roundX-1] == 4  ) {	//Ako je neprijatelj ispod nas, ubijamo ga
			score += 10;
			map[roundY+1][roundX] = 0;
			map[roundY+1][roundX+1] = 0;
			map1[roundY+1][roundX+map_move] = 0;
			map1[roundY+1][roundX+map_move] = 0;
		}*/
	if (map[roundY+1][roundX] == 4)
	{
		score += 10;
		map[roundY+1][roundX] = 0;
		map1[roundY+1][roundX+map_move] = 0;

	}

	if (map[roundY+1][roundX+1] == 4)
		{
			score += 10;
			map[roundY+1][roundX+1] = 0;
			map1[roundY+1][roundX+1+map_move] = 0;
		}

	if (map[roundY+1][roundX-1] == 4)
		{
			score += 10;
			map[roundY+1][roundX-1] = 0;
			map1[roundY+1][roundX-1+map_move] = 0;
		}

	if (map[roundY][roundX] == 4 ||  map[roundY][roundX+1] == 4 || map[roundY][roundX-1] == 4) {
	//centar, iznad, iznad levo, iznad desno, levo, desno = smrt
		lives--;
		hard_reset(ch);
		map_reset(map1);
		map_update(ch);
		chhar_spawn(ch);
		chhar_spawn(&enemie2);

	}

}
void enemie(characters* ch1,characters* ch2){
	u8 roundX = ch1->x >> 4;
		u8 roundY = ch1->y >> 4;
		u8 roundX1 = ch2->x >> 4;
				u8 roundY1 = ch2->y >> 4;



		if(roundX == roundX1 && roundY+1 == roundY1){
				ch2->destroyed = b_true;
		}else if(roundX-1 == roundX1 && roundY+1 == roundY1){
				ch2->destroyed = b_true;
		}else if(roundX+1 == roundX1 && roundY+1 == roundY1){
				ch2->destroyed = b_true;
		}else if (ch1->x == ch2->x && ch1->y == ch2->y)
		{
					lives--;
					hard_reset(ch1);
					map_reset(map1);
					map_update(ch1);
					chhar_spawn(ch1);
					chhar_spawn(ch2);
					ch2 ->destroyed = b_false;

		}


}

void coin_detection(characters* ch, bool have_coin[9]){
	for(int i = 0; i < 9; i++){
		have_coin[i] = false;
	}

	u8 roundX = ch->x >> 4;
	u8 roundY = ch->y >> 4;

		if (map[roundY][roundX] == 5) {/////
			have_coin[P_L] = true;
			map[roundY][roundX] = 0;
			map1[roundY][roundX+map_move] = 0;
			coins++;
		}
		if (map[roundY][roundX+1] == 5) {/////
			have_coin[P_R] = true;
			map[roundY][roundX+1] = 0;
			map1[roundY][roundX+1+map_move] = 0;
			coins++;
		}

		if (map[roundY+1][roundX] == 5)
				{
					//have_coin[P_R] = true;
					map[roundY+1][roundX] = 0;
					map1[roundY+1][roundX+map_move] = 0;
					coins++;
				}

		if (map[roundY+1][roundX+1] == 5)
						{
							//have_coin[P_R] = true;
							map[roundY+1][roundX+1] = 0;
							map1[roundY+1][roundX+1+map_move] = 0;
							coins++;
						}


		/*if (map[roundY+1][roundX] == 5 || map[roundY+1][roundX+1] == 5){/////
			have_coin[P_D] = true;
			map[roundY+1][roundX] = 0;
			map[roundY+1][roundX+1] = 0;
			map1[roundY+1][roundX+map_move] = 0;
			map1[roundY+1][roundX+1+map_move] = 0;
			coins++;
		}
		if (map[roundY+1][roundX] == 5 || map[roundY+1][roundX+1] == 5) {/////
			have_coin[P_DR] = true;
			map[roundY][roundX] = 0;
			map[roundY+1][roundX] = 0;
			map1[roundY][roundX+map_move] = 0;
			map1[roundY+1][roundX+map_move] = 0;
			coins++;
		}
		if (map[roundY+1][roundX] == 5 || map[roundY+1][roundX+1] == 5) {//////
			have_coin[P_DL] = true;
			map[roundY][roundX] = 0;
			map[roundY+1][roundX+1] = 0;
			map1[roundY][roundX+map_move] = 0;
			map1[roundY+1][roundX+1+map_move] = 0;
			coins++;
		}*/

		if(coins >= 10){
			lives++;
			coins = 0;
		}
}

void obstacle_detection( characters* ch, bool have_obstacle[9],bool have_coin[9], u8 jump_cnt) {
	for(int i=0;i<9;i++){
		have_obstacle[i]=false;
	}

	u8 roundX = ch->x >> 4;
	u8 roundY = ch->y >> 4;

	enemy_detection(ch);
	coin_detection(ch,&have_coin);

	if (map[roundY][roundX] != 0) {/////
		have_obstacle[P_L] = true;
	}
	if (map[roundY][roundX+1] != 0) {/////
		have_obstacle[P_R] = true;
	}
	if (map[roundY][roundX] != 0 || map[roundY][roundX+1] != 0){/////
		have_obstacle[P_U] = true;
	}
	if (map[roundY+1][roundX] != 0 || map[roundY+1][roundX+1] != 0){/////
		have_obstacle[P_D] = true;
	}
	if (map[roundY][roundX] != 0 || map[roundY][roundX+1] != 0) {
		have_obstacle[P_UR] = true;
	}
	if (map[roundY][roundX] != 0 || map[roundY][roundX-1] != 0){
		have_obstacle[P_UL] = true;
	}
	if (map[roundY+1][roundX] != 0 || map[roundY+1][roundX-1] != 0) {/////
		have_obstacle[P_DR] = true;
	}
	if (map[roundY+1][roundX] != 0 || map[roundY+1][roundX+1] != 0) {//////
		have_obstacle[P_DL] = true;
	}

}

void obstacle_detection_enemie( characters* ch, bool have_obstacle[9]) {
	for(int i=0;i<9;i++){
		have_obstacle[i]=false;
	}

	u8 roundX = ch->x >> 4;
	u8 roundY = ch->y >> 4;


	if (map[roundY][roundX] != 0) {/////
		have_obstacle[P_L] = true;
	}
	if (map[roundY][roundX+1] != 0) {/////
		have_obstacle[P_R] = true;
	}
	if (map[roundY-1][roundX]){/////
		have_obstacle[P_U] = true;
	}
	if (map[roundY+1][roundX] != 0){/////
		have_obstacle[P_D] = true;
	}
	if (map[roundY-1][roundX+1]) {
		have_obstacle[P_UR] = true;
	}
	if (map[roundY-1][roundX-1] != 0){
		have_obstacle[P_UL] = true;
	}
	if (map[roundY+1][roundX+1] != 0) {/////
		have_obstacle[P_DR] = true;
	}
	if (map[roundY+1][roundX-1] != 0) {//////
		have_obstacle[P_DL] = true;
	}

}
static bool_t enemie_move(characters* ch1, characters* ch2){
	u8 roundX = ch2->x >> 4;
	u8 roundY = ch2->y >> 4;
	static bool have_obstacle[9];


	obstacle_detection_enemie(ch2, &have_obstacle);
	enemie(ch1,ch2);

	switch (e_dir) {
		case 0:
			if(!have_obstacle[P_L]){
				ch2->x--;
			}else{e_dir = 1;}

			break;

		case 1:
			if(!have_obstacle[P_R]){
				ch2->x++;
			}else{e_dir = 0;}

			break;

	}

	Xil_Out32(
				XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + ch2->reg_h ),
				(ch2->y << 16) | ch2->x);
	if(ch2->destroyed == b_true){
		Xil_Out32(
						XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + ch2->reg_h ),
						(ch2->y << 0) | ch2->x);
		ch2 -> x = 0;
		ch2 -> y = 0;
	}

	return b_false;
}

static bool_t character_move(characters* ch, direction_t dir, bool up_pressed) {

	static jump_fsm_t jump_fsm = J_IDLE;
	static u8 jump_cnt;

	unsigned int buttons = XIo_In32( XPAR_IO_PERIPH_BASEADDR );

	direction_t d = DIR_STILL;
	if (BTN_LEFT(buttons)) {
		ch->dir = DIR_LEFT;
		ch->type = IMG_16x16_walken;
		d = DIR_LEFT;
	} else if (BTN_RIGHT(buttons)) {
		ch->dir = DIR_RIGHT;
		ch->type = IMG_16x16_mario;
		d = DIR_RIGHT;
	}
	static bool have_obstacle[9];
	static bool have_coin[9];

	//direction_t dir_obs=DIR_STILL;
	obstacle_detection(ch, &have_obstacle,&have_coin, jump_cnt);
	// Jump FSM funkcija prelaza.
	switch (jump_fsm) {
	case J_IDLE:
		if (up_pressed && have_obstacle[P_D]) {
			jump_fsm = J_GOING_UP;
		}
		break;
	case J_GOING_UP:
		if (jump_cnt == MAX_JUMP) {
			jump_fsm = J_WAIT_UP_RELESE;
		}

		switch (dir) {
		case DIR_STILL:
			if(have_obstacle[P_U]){
				jump_fsm = J_WAIT_UP_RELESE;
			}
			break;
		case DIR_LEFT:
			if(have_obstacle[P_UL]){
				jump_fsm = J_WAIT_UP_RELESE;
			}
			break;
		case DIR_RIGHT:
			if(have_obstacle[P_UR]){
				jump_fsm = J_WAIT_UP_RELESE;
			}
			break;
		}

		break;
	case J_WAIT_UP_RELESE:
		if (!up_pressed) {
			jump_fsm = J_IDLE;
		}
		break;
	}

	// Jump FSM funkcija izlaza.
	switch (jump_fsm) {
	case J_IDLE:
		break;
	case J_GOING_UP:
		ch->y--;
		jump_cnt++;
		break;
	case J_WAIT_UP_RELESE:
		jump_cnt = 0;
		break;
	}


	// Falling.

	if(jump_fsm != J_GOING_UP){ // Cannot fall if going up in jumping.

		switch (dir) {
		case DIR_STILL:
			if(!have_obstacle[P_D]){
				ch->y++;
			}
			break;
		case DIR_LEFT:
			//Probam ovde da mu zamenim sprajt
			if(!have_obstacle[P_DL]){
				ch->y++;
			}
			break;
		case DIR_RIGHT:
			if(!have_obstacle[P_DR]){
				ch->y++;
			}
			break;
		}
	}

	// Moving.

	switch (dir) {
	case DIR_STILL:
		break;
	case DIR_LEFT:
		if(!have_obstacle[P_L]){
			ch->x--;
		}
		break;
	case DIR_RIGHT:
		if(!have_obstacle[P_R]){
			ch->x++;
		}
		break;
	}


	Xil_Out32(
			XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + ch->reg_h ),
			(ch->y << 16) | ch->x);

	return b_false;
}

void battle_city() {


	unsigned int buttons; /*, tmpBtn = 0, tmpUp = 0;*/
	int i;/*, change = 0, jumpFlag = 0;*/
	/*int block;*/
	/*for(int i = 0; i < 30; i++){  napraviti pocetnu mapu
		for(int j = 0; j <= 160; j++){
			map_static[i][j] = map1[i][j];
		}
	}*/

	map_reset(map1);
	map_update(&mario);

		//OVO PITAMO SUBOTICA DA LI RADI!!

	chhar_spawn(&mario);
	//chhar_spawn(&enemie1);
	chhar_spawn(&enemie2);


	//map[enemie2 -> x][enemie2 ->y] = '5';
	//chhar_spawn(&enemie3);
	//chhar_spawn(&enemie4);
	if(lives == 0)
		lives = 3;


	while (1) {
		char_move_cnt++;

		if(char_move_cnt == STEP){
			char_move_cnt = 0;
		}
		buttons = XIo_In32( XPAR_IO_PERIPH_BASEADDR );

		direction_t d = DIR_STILL;
		direction_t e1 = DIR_RIGHT;

		if (BTN_LEFT(buttons)) {
			d = DIR_LEFT;
			if(char_move_cnt == 0){
				mario.type = IMG_16x16_walken;
				chhar_spawn(&mario);
			}
		} else if (BTN_RIGHT(buttons)) {
			d = DIR_RIGHT;
			if (char_move_cnt==0){
				mario.type=IMG_16x16_walken_back;
				chhar_spawn(&mario);
			}
		}else{
			mario.type = IMG_16x16_mario;
			chhar_spawn(&mario);

		}

		/*if(d = DIR_STILL){
			mario.type = IMG_16x16_mario;
			chhar_spawn(&mario);
		}*/
		bool up_pressed = BTN_UP(buttons);

		character_move(&mario, d, up_pressed);
		enemie_move(&mario,&enemie2);


		map_update(&mario);


		for (i = 0; i < 55000; i++) {
		}

	}
}
